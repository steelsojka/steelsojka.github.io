(function($, window) {


  var directives = [];

  // This is my implementation for angularJS directives. I don't need full blown
  // angularJS, but I want some form of declarative binding to attach functionality
  // to elements. We don't get dependency injection and all that fun stuff
  // but this is just a quick way to get directives ;)
  window.directive = function(name, fn) {
    directives.push({
      name: name,
      fn: fn
    });
  };

  // Sub pub emitter
  var emitter = $({});
 
  // Processes all our "directives"
  function processDirectives() {
    $.each(directives, function(index, directive) {
      $("[data-" + directive.name + "]").each(function() {
        directive.fn($(this), emitter);
      });
    });
  };

  $(function() {
    processDirectives();
  });

}(jQuery, window));

directive("hover-event", function(element, emitter) {
  var event = element.data("hover-event");
  var data = element.data("hover-event-data");

  element
    .on("mouseenter", function() {
      emitter.trigger(event + ":on", [data]);
    })
    .on("mouseout", function() {
      emitter.trigger(event + ":off", [data]);
    });
});

directive("scroll-animate", function(element) {
  var SCROLL_DURATION = 300;
  var $this = $(this);
  var $target = $(element.data("scroll-animate"));
  var $html = $("html, body");

  element.on("click", function(event) {
    $html.animate({
      scrollTop: $target.offset().top
    }, SCROLL_DURATION);
  });
});

directive("scroll-spy", function(element, emitter) {
  var ACTIVE_CLASS = "active";
  var $prevSource, prevTarget;
  var $window = $(window);
  var navHeight = $(".sticky-nav").height();

  var sourceElements = element.find("[data-scroll-source]").map(function() {
    var $this = $(this);

    return {
      $el: $this,
      offset: $this.data("scroll-offset") || 0,
      id: $this.data("scroll-source")
    };
  });

  // Grab our targets initially so we don't have to do it in the onScroll listener
  var targets = element.find("[data-scroll-target]").map(function() {
    var $this = $(this);

    return {
      $el: $this,
      id: $this.data("scroll-target"),
      data: $this.data("scroll-spy-data")
    };
  });

  var activeTargets = element.find("[data-scroll-active]");

  var onScroll = function(event) {
    var windowTop = $window.scrollTop();
    var targetToChange, sourceToChange;
    var isChanged = false;

    $.each(sourceElements, function(index, source) {
      if (source.$el[0].offsetTop - navHeight + source.offset <= windowTop) {
        sourceToChange = source;
        isChanged = $prevSource ? $prevSource.$el[0] !== source.$el[0] : true;
      }
    });

    if (!isChanged) {
      return;
    }

    sourceToChange.$el.addClass(ACTIVE_CLASS);
    $prevSource && $prevSource.$el.removeClass(ACTIVE_CLASS);
    $prevSource = sourceToChange;

    if (prevTarget) {
      activeTargets.removeClass("scroll-target-" + prevTarget.id);
      prevTarget.$el.removeClass(ACTIVE_CLASS);
    }

    var target = $.grep(targets, function(target) {
      return sourceToChange.id === target.id;
    });

    if (target.length) {
      target[0].$el.addClass(ACTIVE_CLASS);
      emitter.trigger("scroll-spy:change", [target[0]]);
      activeTargets.addClass("scroll-target-" + target[0].id);
      prevTarget = target[0];
    }
  };

  setTimeout(onScroll(), 0);

  $window.on("scroll", onScroll);
});


directive("simple-spy", function(element) {
  var ABOVE_CLASS = "simple-spy-above";
  var BELOW_CLASS = "simple-spy-below";

  var target = element.data("simple-spy");

  if (!target) {
    return;
  }

  target = $(target).map(function() {
    var $this = $(this);

    return {
      $el: $this,
      top: $this.offset().top,
      offset: $this.data("simple-spy-offset") || 0
    };
  })[0];

  var $window = $(window);
  var activeClass = ABOVE_CLASS;

  var onScroll = function(event) {
    var windowTop = $window.scrollTop();

    if (target.top - target.offset <= windowTop && activeClass !== ABOVE_CLASS) {
      activeClass = ABOVE_CLASS;
      element.addClass(ABOVE_CLASS).removeClass(BELOW_CLASS);
    } else if (target.top -target.offset > windowTop && activeClass !== BELOW_CLASS) {
      activeClass = BELOW_CLASS;
      element.addClass(BELOW_CLASS).removeClass(ABOVE_CLASS);
    }
  };

  $window.on("scroll", onScroll);

});

directive("typeout", function(element, emitter) {
  var template = "<span class='typeout'>" + (element.data("typeout-default") || "") + "</span><span class='typeout-cursor'></span>";

  var speed = 350;
  var hidden = false;
  var text = element.data("typeout") || "";
  var event = element.data("typeout-change-event") || "typeout";

  element.html(template);

  var cursor = element.find(".typeout-cursor").text("|");
  var textEl = element.find(".typeout");

  var blink = function() {
    cursor.css("opacity", (hidden ? 1 : 0));
    hidden = !hidden;
  };

  var setText = function(message) {
    text = message.split("");
  };

  var typeout = function(reverse) {
    var index = reverse ? text.length : 1;
    var typingText = text.join("");

    var typeChar = function() {
      textEl.text(text.slice(0, index).join(""));

      index = reverse ? index - 1 : index + 1;

      var nextChar = reverse ? index >= 0 : index <= text.length;

      if (nextChar && typingText === text.join("")) {
        setTimeout(typeChar, 50);
      }
    };

    typeChar();
  };

  setInterval(blink, speed);

  blink();
  setText(text);

  emitter.on(event, function(e, target) {
    if (target.data) {
      setText(target.data);
    }

    typeout();
  });
});
